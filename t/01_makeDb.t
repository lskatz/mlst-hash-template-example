#!/usr/bin/env perl

use strict;
use warnings;
use Data::Dumper;
use Test::More;
use FindBin qw/$RealBin/;
use File::Basename qw/basename/;
use Digest::MD5 qw/md5_base64/;

plan tests => 1;

$ENV{PATH} = "$RealBin/../scripts:$ENV{PATH}";

my $indir  = "$RealBin/senterica";
my $outdir = "$RealBin/senterica.dbh";
subtest 'build senterica' => sub{
  system("digestFasta.pl --force --out $outdir $indir/*.tfa");
  if($?){
    BAIL_OUT("digestFasta.pl failed to run");
  }

  # Make sure the database was made at all
  is(-e "$outdir/alleles.tsv", 1, "Check existence of alleles.tsv");
  is(-e "$outdir/ref.fasta", 1, "Check existence of ref.fasta");

  # Check how many of each locus there are with the example database
  my %expLocusCount = (
    aroC => 984,
    dnaN => 975,
    hemD => 916,
    hisD => 1380,
    purE => 1075,
    sucA => 1002,
    thrA => 1156,
  );
  my %obsLocusCount;

  # Also check to see if we see the reference allele hash
  my %expHash = (
    '6GUMqxkMYXpIDEPWB7GXJg' => "aroC",
    '1AF2Py325f6H4eB9PBcP5g' => "dnaN",
    '/kXf/b7JIRAdxKQR2OWB2A' => "hemD",
    'n3YsJGxULFLJTFAiymIxHA' => "hisD",
    '3+0cJja2LgafXtLwFWlSRg' => "purE",
    'SBtkVPM/rnh1tJeMFAlOww' => "sucA",
    '6uxkS0Eb0LOrHghvur0pyQ' => "thrA",
  );
  my %obsHash;

  open(my $allelesFh, "$outdir/alleles.tsv") or die "ERROR: cannot read $outdir/alleles.tsv: $!";
  while(<$allelesFh>){
    next if(/^#/);
    my($locus, $hash) = split(/\t/);
    $obsLocusCount{$locus}++;

    # If the hash is found, set it equal to the locus
    # to help with the exactness of the unit test.
    if($expHash{$hash}){
      $obsHash{$hash} = $locus;
    }
  }
  close $allelesFh;
  is_deeply(\%obsLocusCount, \%expLocusCount, "Number of expected loci");
  is_deeply(\%obsHash, \%expHash, "Reference allele hashes");

  # Check the reference sequences
  my %expRef = (
    aroC_1 => "GTTTTTCGCCCGGGACACGCGGATTACACCTATGAGCAGAAATACGGCCTGCGCGATTACCGCGGCGGTGGACGTTCTTCCGCGCGTGAAACCGCGATGCGCGTAGCGGCAGGGGCGATCGCCAAGAAATACTTGGCGGAAAAGTTCGGCATCGAAATCCGCGGCTGCCTGACCCAGATGGGCGACATTCCGCTGGAGATTAAAGACTGGCGTCAGGTTGAGCTTAATCCGTTCTTTTGCCCCGATGCGGACAAACTTGACGCGCTGGACGAACTGATGCGCGCGCTGAAAAAAGAGGGTGACTCCATCGGCGCGAAAGTGACGGTGATGGCGAGCGGCGTGCCGGCAGGGCTTGGCGAACCGGTATTTGACCGACTGGATGCGGACATCGCCCATGCGCTGATGAGCATCAATGCGGTGAAAGGCGTGGAGATCGGCGAAGGATTTAACGTGGTGGCGCTGCGCGGCAGCCAGAATCGCGATGAAATCACGGCGCAGGGT",
    dnaN_1 => "ATGGAGATGGTCGCGCGCGTTACGCTTTCTCAGCCGCATGAGCCAGGCGCCACTACCGTGCCGGCGCGGAAATTCTTTGATATCTGCCGCGGCCTGCCGGAGGGCGCGGAGATTGCCGTTCAGTTGGAAGGCGATCGGATGCTGGTGCGTTCTGGCCGTAGCCGCTTCTCGCTGTCTACGCTGCCTGCCGCCGATTTCCCGAATCTTGACGACTGGCAAAGCGAAGTTGAATTTACGCTGCCGCAGGCCACGATGAAGCGCCTGATTGAAGCGACCCAGTTTTCGATGGCCCATCAGGATGTGCGCTACTACTTAAACGGTATGCTGTTTGAAACGGAAGGTAGCGAACTGCGCACTGTTGCGACCGACGGCCACCGTCTGGCGGTGTGCTCAATGCCGCTGGAGGCGTCTTTACCTAGCCACTCGGTGATTGTGCCGCGTAAAGGCGTGATTGAACTGATGCGTATGCTCGACGGTGGCGAAAACCCGCTGCGCGTGCAG",
    hemD_1 => "GCAACGCTGACGGAAAACGATCTGGTTTTTGCCCTTTCACAGCACTCCGTCGCCTTTGCTCACGCCCAGCTCCAGCGGGATGGACGAAACTGGCCTGCGTCGCCGCGCTATTTCTCGATTGGCCGCACTACGGCGCTCGCCCTTCATACCGTTAGCGGGTTCGATATTCGTTATCCATTGGATCGGGAAATCAGCGAAGCCTTGCTACAATTACCTGAATTACAAAATATTGCGGGCAAACGCGCGCTGATTTTGCGTGGCAATGGCGGCCGCGAACTGCTGGGCGAAACCCTGACAGTTCGCGGAGCCGAAGTCAGTTTTTGTGAATGTTATCAACGATGTGCGAAACATTACGATGGCGCGGAAGAAGCGATGCGCTGGCATACTCGCGGCGTAACAACGCTTGTTGTTACCAGCGGCGAGATGTTGCAA",
    hisD_1 => "ATTGCGGGATGCCAGAAGGTGGTTCTGTGCTCGCCGCCACCCATCGCTGATGAAATCCTCTATGCGGCGCAACTGTGTGGCGTGCAGGAAATCTTTAACGTCGGCGGCGCGCAGGCGATTGCCGCTCTGGCCTTCGGCAGCGAGTCCGTACCGAAAGTGGATAAAATTTTTGGCCCCGGCAACGCCTTTGTAACCGAAGCCAAGCGTCAGGTCAGCCAGCGTCTCGACGGCGCGGCTATCGATATGCCAGCCGGGCCGTCTGAAGTGCTGGTGATCGCCGACAGCGGCGCAACACCGGATTTCGTCGCTTCTGACCTGCTCTCCCAGGCTGAGCACGGCCCGGATTCCCAGGTGATCCTGCTGACGCCGGATGCTGACATTGCCCGCAAGGTGGCGGAGGCGGTAGAACGTCAACTGGCGGAACTGCCGCGCGCGGGCACCGCCCGGCAGGCCCTGAGCGCCAGTCGTCTGATTGTGACCAAAGATTTAGCGCAGTGCGTC",
    purE_1 => "AGCGACTGGGCTACCATGCAATTCGCCGCCGAAATTTTTGAAATTCTGGATGTCCCGCACCATGTAGAAGTGGTTTCCGCCCATCGCACCCCCGATAAACTGTTCAGCTTCGCCGAAACGGCGGAAGAGAACGGATATCAAGTGATTATTGCCGGCGCGGGCGGCGCGGCACACCTGCCGGGAATGATTGCGGCAAAAACGCTGGTCCCGGTACTCGGCGTGCCGGTACAAAGCGCTGCGCTCAGCGGCGTGGATAGCCTCTACTCCATCGTGCAGATGCCGCGCGGCATTCCGGTGGGTACGCTGGCGATCGGTAAAGCCGGGGCGGCGAACGCCGCACTGCTGGCAGCGCAAATTTTGGCTACGCATGATAGCGCGCTGCATCGGCGCATCGCCGAC",
    sucA_1 => "AAACGCTTCCTGAACGAACTGACCGCCGCTGAAGGGCTGGAACGTTATCTGGGCGCCAAATTCCCGGGTGCGAAACGTTTCTCGCTCGAGGGGGGAGATGCGCTGATACCTATGCTGAAAGAGATGGTTCGCCATGCGGGTAACAGCGGCACTCGCGAAGTGGTGCTGGGGATGGCGCACCGCGGTCGTCTGAACGTGCTGATCAACGTACTGGGTAAAAAACCGCAGGATCTGTTCGACGAGTTTGCCGGTAAACATAAAGAACATCTGGGTACCGGCGACGTGAAGTATCACATGGGCTTCTCGTCAGATATCGAAACTGAAGGCGGTCTGGTTCACCTGGCGCTGGCGTTTAACCCATCGCATCTGGAAATTGTGAGCCCGGTGGTGATGGGCTCCGTGCGCGCCCGTCTGGACCGACTGGACGAACCGAGCAGTAATAAAGTGCTGCCGATCACTATTCACGGCGACGCCGCGGTGACCGGCCAGGGCGTGGTTCAG",
    thrA_1 => "GTGCTGGGCCGTAATGGTTCCGACTATTCCGCCGCCGTGCTGGCCGCCTGTTTACGCGCTGACTGCTGTGAAATCTGGACTGACGTCGATGGCGTGTATACCTGTGACCCGCGCCAGGTGCCGGACGCCAGACTGCTGAAATCGATGTCCTACCAGGAAGCGATGGAACTCTCTTACTTCGGCGCCAAAGTCCTTCACCCTCGCACCATAACGCCTATCGCCCAGTTCCAGATCCCCTGTCTGATTAAAAATACCGGTAATCCGCAGGCGCCAGGAACGCTGATCGGCGCGTCCAGCGACGATGATAATCTGCCGGTTAAAGGGATCTCTAACCTTAACAACATGGCGATGTTTAGCGTCTCCGGCCCGGGAATGAAAGGGATGATTGGGATGGCGGCGCGTGTTTTCGCCGCCATGTCTCGCGCCGGGATCTCGGTGGTGCTCATTACCCAGTCCTCCTCTGAGTACAGCATCAGCTTCTGTGTGCCGCAGAGTGACTGC",
  );

  my %obsRef;
  open(my $seqFh, "<", "$outdir/ref.fasta") or BAIL_OUT("reading $outdir/ref.fasta");
  my ($id, $seq, @aux) = (undef, undef, undef);
  while( ($id, $seq, undef) = readfq($seqFh, \@aux) ){
    $obsRef{$id} = $seq;
  }
  is_deeply(\%obsRef, \%expRef, "Expected reference alleles");
  close $seqFh;
};

sub readfq {
    my ($fh, $aux) = @_;
    @$aux = [undef, 0] if (!(@$aux));	# remove deprecated 'defined'
    return if ($aux->[1]);
    if (!defined($aux->[0])) {
        while (<$fh>) {
            chomp;
            if (substr($_, 0, 1) eq '>' || substr($_, 0, 1) eq '@') {
                $aux->[0] = $_;
                last;
            }
        }
        if (!defined($aux->[0])) {
            $aux->[1] = 1;
            return;
        }
    }
    my $name = /^.(\S+)/? $1 : '';
    my $comm = /^.\S+\s+(.*)/? $1 : ''; # retain "comment"
    my $seq = '';
    my $c;
    $aux->[0] = undef;
    while (<$fh>) {
        chomp;
        $c = substr($_, 0, 1);
        last if ($c eq '>' || $c eq '@' || $c eq '+');
        $seq .= $_;
    }
    $aux->[0] = $_;
    $aux->[1] = 1 if (!defined($aux->[0]));
    return ($name, $seq) if ($c ne '+');
    my $qual = '';
    while (<$fh>) {
        chomp;
        $qual .= $_;
        if (length($qual) >= length($seq)) {
            $aux->[0] = undef;
            return ($name, $seq, $comm, $qual);
        }
    }
    $aux->[1] = 1;
    return ($name, $seq, $comm);
}

